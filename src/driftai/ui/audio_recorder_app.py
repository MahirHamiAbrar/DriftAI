"""
    NOTE: This complete app is originally generated by `claude.ai` and then slightly improvised by the author.
"""

import os
import sys
import time
from typing import NoReturn
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, 
    QHBoxLayout, QPushButton, QLabel, QListWidget, 
    QDoubleSpinBox, QGroupBox, QSlider, QStyle,
    QStyleFactory, QFrame
)
from PyQt6.QtGui import QColor, QPalette, QFont
from PyQt6.QtMultimedia import QMediaPlayer, QAudioOutput
from PyQt6.QtCore import Qt, QUrl, QTimer, QThread, pyqtSignal, pyqtSlot

from driftai.audio import AudioRecorder


class RecordingThread(QThread):
    """Thread class for handling audio recording in the background."""
    recording_stopped = pyqtSignal()
    chunk_saved = pyqtSignal(str)
    
    def __init__(self, recorder: AudioRecorder) -> None:
        super().__init__()
        self.recorder = recorder
    
    def run(self) -> None:
        self.recorder.start_recording()
        # Keep thread running until recording is stopped
        while self.recorder.is_recording:
            time.sleep(0.1)
        self.recording_stopped.emit()


class AudioPlayerApp(QMainWindow):
    def __init__(self, app: QApplication) -> None:
        super().__init__()

        self.app = app
        
        self.setWindowTitle("Audio Recorder and Player")
        self.setMinimumSize(800, 600)
        
        # Apply modern theme
        self.apply_modern_theme()
        
        # Create the audio recorder object with default settings
        self.recorder = AudioRecorder(chunk_duration=2)
        self.recording_thread = None
        
        # Create the media player for playback
        self.player = QMediaPlayer()
        self.audio_output = QAudioOutput()
        self.player.setAudioOutput(self.audio_output)
        
        # Connect media player signals - fixed connections
        self.player.positionChanged.connect(self.position_changed)
        self.player.durationChanged.connect(self.duration_changed)
        self.player.playbackStateChanged.connect(self.state_changed)
        
        # Set up the UI
        self.setup_ui()
        
        # Timer to update the recordings list
        self.update_timer = QTimer(self)
        self.update_timer.timeout.connect(self.update_recordings_list)
        self.update_timer.start(2000)  # Update every 2 seconds
        
        # Initial update
        self.update_recordings_list()
    
    def apply_modern_theme(self) -> None:
        # Set application style to Fusion for a modern look
        QApplication.setStyle(QStyleFactory.create("Fusion"))
        
        # Create a custom dark palette
        dark_palette = QPalette()
        
        # Define colors
        dark_color = QColor(45, 45, 45)
        disabled_color = QColor(127, 127, 127)
        text_color = QColor(240, 240, 240)
        highlight_color = QColor(42, 130, 218)
        accent_color = QColor(0, 120, 215)
        
        # Set colors for different palette roles
        dark_palette.setColor(QPalette.ColorRole.Window, dark_color)
        dark_palette.setColor(QPalette.ColorRole.WindowText, text_color)
        dark_palette.setColor(QPalette.ColorRole.Base, QColor(35, 35, 35))
        dark_palette.setColor(QPalette.ColorRole.AlternateBase, dark_color)
        dark_palette.setColor(QPalette.ColorRole.ToolTipBase, text_color)
        dark_palette.setColor(QPalette.ColorRole.ToolTipText, text_color)
        dark_palette.setColor(QPalette.ColorRole.Text, text_color)
        # dark_palette.setColor(QPalette.ColorRole.Disabled, QPalette.ColorGroup.All, disabled_color)
        dark_palette.setColor(QPalette.ColorRole.Button, dark_color)
        dark_palette.setColor(QPalette.ColorRole.ButtonText, text_color)
        dark_palette.setColor(QPalette.ColorRole.BrightText, Qt.GlobalColor.red)
        dark_palette.setColor(QPalette.ColorRole.Link, accent_color)
        dark_palette.setColor(QPalette.ColorRole.Highlight, highlight_color)
        dark_palette.setColor(QPalette.ColorRole.HighlightedText, Qt.GlobalColor.black)
        
        # Apply the palette
        self.app.setPalette(dark_palette)
        
        # Set stylesheet for additional customization
        self.app.setStyleSheet("""
            QMainWindow {
                background-color: #2d2d2d;
            }
            QGroupBox {
                border: 1px solid #3a3a3a;
                border-radius: 5px;
                margin-top: 20px;
                font-weight: bold;
                color: #e0e0e0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding: 0 10px;
            }
            QPushButton {
                background-color: #0078d7;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 6px 12px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #0086f0;
            }
            QPushButton:pressed {
                background-color: #0069be;
            }
            QPushButton:disabled {
                background-color: #555555;
                color: #888888;
            }
            QSlider::groove:horizontal {
                border: 1px solid #999999;
                height: 8px;
                background: #3a3a3a;
                margin: 2px 0;
                border-radius: 4px;
            }
            QSlider::handle:horizontal {
                background: #0078d7;
                border: 1px solid #5c5c5c;
                width: 16px;
                margin: -4px 0;
                border-radius: 8px;
            }
            QSlider::handle:horizontal:hover {
                background: #0086f0;
            }
            QListWidget {
                background-color: #333333;
                border-radius: 4px;
                border: 1px solid #3a3a3a;
                padding: 5px;
            }
            QListWidget::item {
                height: 25px;
                border-radius: 2px;
            }
            QListWidget::item:selected {
                background-color: #0078d7;
                color: white;
            }
            QDoubleSpinBox {
                background-color: #333333;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 4px;
            }
            QLabel {
                color: #e0e0e0;
            }
        """)
    
    def setup_ui(self) -> None:
        # Create central widget and main layout
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        main_layout.setSpacing(15)
        main_layout.setContentsMargins(15, 15, 15, 15)
        
        # App title and description
        header_layout = QVBoxLayout()
        title_label = QLabel("Audio Recorder")
        title_label.setFont(QFont("Arial", 18, QFont.Weight.Bold))
        description_label = QLabel("Record and play audio files with customizable chunk duration")
        description_label.setFont(QFont("Arial", 10))
        
        header_layout.addWidget(title_label)
        header_layout.addWidget(description_label)
        
        # Separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        
        # Recording controls group
        recording_group = QGroupBox("Recording Controls")
        recording_layout = QVBoxLayout(recording_group)
        recording_layout.setSpacing(10)
        
        # Chunk duration controls
        duration_layout = QHBoxLayout()
        duration_label = QLabel("Chunk Duration (seconds):")
        self.duration_spinner = QDoubleSpinBox()
        self.duration_spinner.setRange(0.5, 60.0)
        self.duration_spinner.setValue(2.0)
        self.duration_spinner.setSingleStep(0.5)
        self.duration_spinner.setFixedWidth(100)
        duration_layout.addWidget(duration_label)
        duration_layout.addWidget(self.duration_spinner)
        duration_layout.addStretch()
        
        # Record button
        self.record_button = QPushButton("Start Recording")
        self.record_button.setMinimumHeight(40)
        self.record_button.clicked.connect(self.toggle_recording)
        
        recording_layout.addLayout(duration_layout)
        recording_layout.addWidget(self.record_button)
        
        # Recordings list group
        recordings_group = QGroupBox("Recorded Audio Files")
        recordings_layout = QVBoxLayout(recordings_group)
        recordings_layout.setSpacing(10)
        
        self.recordings_list = QListWidget()
        self.recordings_list.setAlternatingRowColors(True)
        self.recordings_list.itemDoubleClicked.connect(self.play_selected_recording)
        refresh_button = QPushButton("Refresh List")
        refresh_button.clicked.connect(self.update_recordings_list)
        
        recordings_layout.addWidget(self.recordings_list)
        recordings_layout.addWidget(refresh_button)
        
        # Playback controls group
        playback_group = QGroupBox("Playback Controls")
        playback_layout = QVBoxLayout(playback_group)
        playback_layout.setSpacing(10)
        
        # Playback title
        self.playback_title = QLabel("No file selected")
        self.playback_title.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        self.playback_title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Playback slider
        self.position_slider = QSlider(Qt.Orientation.Horizontal)
        self.position_slider.setRange(0, 0)
        self.position_slider.sliderMoved.connect(self.set_position)
        self.position_slider.setMinimumHeight(20)
        
        # Time labels
        time_layout = QHBoxLayout()
        self.current_time_label = QLabel("00:00")
        self.total_time_label = QLabel("00:00")
        time_layout.addWidget(self.current_time_label)
        time_layout.addStretch()
        time_layout.addWidget(self.total_time_label)
        
        # Playback buttons
        buttons_layout = QHBoxLayout()
        
        self.play_button = QPushButton("Play")
        self.play_button.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_MediaPlay))
        self.play_button.clicked.connect(self.play_pause)
        self.play_button.setMinimumWidth(100)
        
        self.stop_button = QPushButton("Stop")
        self.stop_button.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_MediaStop))
        self.stop_button.clicked.connect(self.stop)
        self.stop_button.setMinimumWidth(100)
        
        volume_layout = QHBoxLayout()
        volume_label = QLabel("Volume:")
        
        self.volume_slider = QSlider(Qt.Orientation.Horizontal)
        self.volume_slider.setRange(0, 100)
        self.volume_slider.setValue(70)
        self.volume_slider.valueChanged.connect(self.set_volume)
        
        volume_layout.addWidget(volume_label)
        volume_layout.addWidget(self.volume_slider)
        
        buttons_layout.addWidget(self.play_button)
        buttons_layout.addWidget(self.stop_button)
        buttons_layout.addLayout(volume_layout)
        
        playback_layout.addWidget(self.playback_title)
        playback_layout.addWidget(self.position_slider)
        playback_layout.addLayout(time_layout)
        playback_layout.addLayout(buttons_layout)
        
        # Add components to main layout
        main_layout.addLayout(header_layout)
        main_layout.addWidget(separator)
        main_layout.addWidget(recording_group)
        main_layout.addWidget(recordings_group)
        main_layout.addWidget(playback_group)
        
        # Set the central widget
        self.setCentralWidget(central_widget)
        
        # Initialize volume
        self.set_volume(self.volume_slider.value())
    
    def toggle_recording(self) -> None:
        if self.recorder.is_recording:
            # Stop recording
            self.record_button.setText("Start Recording")
            self.recorder.stop_recording()
            if self.recording_thread:
                self.recording_thread.quit()
                self.recording_thread.wait()
        else:
            # Set chunk duration from spinner
            chunk_duration = self.duration_spinner.value()
            self.recorder.set_chunk_duration(chunk_duration)
            
            # Start recording in a separate thread
            self.record_button.setText("Stop Recording")
            self.recording_thread = RecordingThread(self.recorder)
            self.recording_thread.recording_stopped.connect(self.on_recording_stopped)
            self.recording_thread.start()
    
    @pyqtSlot()
    def on_recording_stopped(self) -> None:
        self.record_button.setText("Start Recording")
        self.update_recordings_list()
    
    def update_recordings_list(self) -> None:
        # Save current selection if any
        current_item = self.recordings_list.currentItem()
        current_file = current_item.text() if current_item else None
        
        # Clear and repopulate the list
        self.recordings_list.clear()
        
        if os.path.exists(self.recorder.output_dir):
            files = [f for f in os.listdir(self.recorder.output_dir) if f.endswith('.mp3')]
            files.sort(reverse=True)  # Most recent first
            
            for file in files:
                self.recordings_list.addItem(file)
            
            # Restore selection if possible
            if current_file:
                items = self.recordings_list.findItems(current_file, Qt.MatchFlag.MatchExactly)
                if items:
                    self.recordings_list.setCurrentItem(items[0])
    
    def play_selected_recording(self, item) -> None:
        file_path = os.path.join(self.recorder.output_dir, item.text())
        self.play_file(file_path)
    
    def play_file(self, file_path) -> None:
        # Make sure file exists
        if not os.path.exists(file_path):
            self.playback_title.setText(f"Error: File not found")
            return
            
        # Set file as source and prepare player
        self.player.stop()  # Stop any current playback
        self.playback_title.setText(os.path.basename(file_path))
        
        # Convert to absolute path for QUrl
        abs_path = os.path.abspath(file_path)
        # Fix: Properly create QUrl from local file
        url = QUrl.fromLocalFile(abs_path)
        
        # Debug output
        print(f"Playing file: {abs_path}")
        print(f"URL: {url.toString()}")
        
        # Set source and play
        self.player.setSource(url)
        # Ensure audio output is connected
        self.player.setAudioOutput(self.audio_output)
        
        # Set initial volume
        self.set_volume(self.volume_slider.value())
        
        # Play after a short delay to allow loading
        QTimer.singleShot(100, self.player.play)
    
    def play_pause(self) -> None:
        if self.player.playbackState() == QMediaPlayer.PlaybackState.PlayingState:
            self.player.pause()
            self.play_button.setText("Play")
            self.play_button.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_MediaPlay))
        else:
            self.player.play()
            self.play_button.setText("Pause")
            self.play_button.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_MediaPause))
    
    def stop(self) -> None:
        self.player.stop()
        self.play_button.setText("Play")
        self.play_button.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_MediaPlay))
    
    def set_volume(self, volume) -> None:
        # Fix: Set volume properly
        self.audio_output.setVolume(volume / 100.0)
        print(f"Volume set to: {volume / 100.0}")
    
    def set_position(self, position) -> None:
        # Fix: Set position only when slider is being dragged
        if self.position_slider.isSliderDown():
            self.player.setPosition(position)
    
    def position_changed(self, position) -> None:
        # Only update slider if it's not being dragged
        if not self.position_slider.isSliderDown():
            self.position_slider.setValue(position)
        
        # Update time display
        seconds = position // 1000
        minutes = seconds // 60
        seconds %= 60
        self.current_time_label.setText(f"{minutes:02d}:{seconds:02d}")
    
    def duration_changed(self, duration) -> None:
        self.position_slider.setRange(0, duration)
        
        # Update total time display
        seconds = duration // 1000
        minutes = seconds // 60
        seconds %= 60
        self.total_time_label.setText(f"{minutes:02d}:{seconds:02d}")
    
    def state_changed(self, state) -> None:
        if state == QMediaPlayer.PlaybackState.PlayingState:
            self.play_button.setText("Pause")
            self.play_button.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_MediaPause))
        else:
            self.play_button.setText("Play")
            self.play_button.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_MediaPlay))
    
    def closeEvent(self, event) -> None:
        # Ensure recording is stopped when application is closed
        if self.recorder.is_recording:
            self.recorder.stop_recording()
            if self.recording_thread:
                self.recording_thread.quit()
                self.recording_thread.wait()
        event.accept()


def run_audio_recorder_app() -> NoReturn:
    app = QApplication(sys.argv)
    window = AudioPlayerApp(app)
    window.show()
    sys.exit(app.exec())
