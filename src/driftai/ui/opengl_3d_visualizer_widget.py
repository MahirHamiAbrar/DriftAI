import colorsys
import numpy as np

from enum import Enum
from typing import Any

from OpenGL.GL import *
from OpenGL.GLU import *

from PyQt6.QtGui import QSurfaceFormat
from PyQt6.QtOpenGLWidgets import QOpenGLWidget


class GLVisualizerColorMode(Enum):
    Rainbow = 0
    Spectrum = 1
    Fire = 2
    Ocean = 3
    Candy = 4


class OpenGL3DVisualizerWidget(QOpenGLWidget):
    """ This Class is generated by 'Claude 3.7 Sonnet' """
    
    def __init__(self, parent=None) -> None:
        super().__init__(parent)
        self.parent = parent
        self.rotation = 0.0
        self.spectrum_data = np.zeros(64)
        self.waveform_data = np.zeros(128)
        self.bass_energy = 0.0
        self.color_shift = 0.0
        self.particles = []
        self.color_mode = GLVisualizerColorMode.Spectrum  # Default color mode
        
        # Set up OpenGL format
        fmt = QSurfaceFormat()
        fmt.setSamples(8)  # Higher anti-aliasing for smoother visuals
        self.setFormat(fmt)
    
    def initializeGL(self) -> None:
        glClearColor(0.0, 0.0, 0.05, 1.0)  # Dark blue background
        glEnable(GL_DEPTH_TEST)
        glEnable(GL_BLEND)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
        
        # Initialize particles
        self.init_particles(100)
    
    def init_particles(self, count) -> None:
        self.particles = []
        for _ in range(count):
            # Random position in a sphere
            theta = np.random.random() * 2 * np.pi
            phi = np.random.random() * np.pi
            r = 3 + np.random.random() * 2
            
            x = r * np.sin(phi) * np.cos(theta)
            y = r * np.sin(phi) * np.sin(theta)
            z = r * np.cos(phi)
            
            # Random color
            color = [np.random.random(), np.random.random(), np.random.random()]
            
            # Random size
            size = 0.02 + np.random.random() * 0.08
            
            self.particles.append({'pos': [x, y, z], 'color': color, 'size': size, 'speed': 0.01 + np.random.random() * 0.02})
    
    def resizeGL(self, width, height) -> None:
        glViewport(0, 0, width, height)
        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        gluPerspective(45, width / height, 0.1, 100.0)
    
    def paintGL(self) -> None:
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        glMatrixMode(GL_MODELVIEW)
        glLoadIdentity()
        
        # Position the camera
        gluLookAt(0, 1, 7, 0, 0, 0, 0, 1, 0)
        
        # Rotate the scene
        glRotatef(self.rotation, 0, 1, 0)
        glRotatef(self.rotation * 0.5, 1, 0, 0)
        
        # Draw background particles
        self.draw_particles()
        
        # Draw spectrum and waveform
        self.draw_spectrum()
        self.draw_waveform()
        
        # Draw central sphere that pulses with bass
        self.draw_central_sphere()
    
    def draw_particles(self) -> None:
        glPointSize(4.0)
        glBegin(GL_POINTS)
        
        for particle in self.particles:
            # Set color with alpha
            glColor4f(particle['color'][0], particle['color'][1], particle['color'][2], 0.7)
            glVertex3f(particle['pos'][0], particle['pos'][1], particle['pos'][2])
        
        glEnd()
    
    def update_particles(self) -> None:
        bass_impact = self.bass_energy * 0.1
        
        for particle in self.particles:
            # Move particles toward center based on bass energy
            direction = np.array([0, 0, 0]) - np.array(particle['pos'])
            direction = direction / np.linalg.norm(direction) if np.linalg.norm(direction) > 0 else direction
            
            # Update position
            speed = particle['speed'] + bass_impact
            particle['pos'][0] += direction[0] * speed
            particle['pos'][1] += direction[1] * speed
            particle['pos'][2] += direction[2] * speed
            
            # Reset particles that get too close to center
            distance = np.sqrt(sum(x**2 for x in particle['pos']))
            if distance < 0.8:
                # Random position in a sphere
                theta = np.random.random() * 2 * np.pi
                phi = np.random.random() * np.pi
                r = 5 + np.random.random() * 2
                
                particle['pos'][0] = r * np.sin(phi) * np.cos(theta)
                particle['pos'][1] = r * np.sin(phi) * np.sin(theta)
                particle['pos'][2] = r * np.cos(phi)
                
                # Update color based on color mode
                if self.color_mode == "rainbow":
                    hue = (self.color_shift + np.random.random()) % 1.0
                    rgb = colorsys.hsv_to_rgb(hue, 0.9, 1.0)
                    particle['color'] = list(rgb)
                elif self.color_mode == "spectrum":
                    particle['color'] = [
                        0.5 + 0.5 * np.sin(self.color_shift * 1.1),
                        0.5 + 0.5 * np.sin(self.color_shift * 0.7 + 2.0),
                        0.5 + 0.5 * np.sin(self.color_shift * 0.5 + 4.0)
                    ]
                elif self.color_mode == "fire":
                    r = 0.8 + 0.2 * np.random.random()
                    g = 0.4 * np.random.random()
                    b = 0.1 * np.random.random()
                    particle['color'] = [r, g, b]
                elif self.color_mode == "ocean":
                    r = 0.1 * np.random.random()
                    g = 0.4 + 0.3 * np.random.random()
                    b = 0.7 + 0.3 * np.random.random()
                    particle['color'] = [r, g, b]
                elif self.color_mode == "candy":
                    hue = (np.random.random() * 0.3 + 0.8) % 1.0  # Pink to purple range
                    if np.random.random() > 0.5:
                        hue = (np.random.random() * 0.2 + 0.5) % 1.0  # Teal to blue range
                    rgb = colorsys.hsv_to_rgb(hue, 0.9, 1.0)
                    particle['color'] = list(rgb)
    
    def get_spectrum_color(self, index, value)-> tuple[float, float, float] | tuple[Any, Any, Any]:
        # Get color based on selected color mode
        if self.color_mode == "rainbow":
            hue = (self.color_shift + index / 64.0) % 1.0
            rgb = colorsys.hsv_to_rgb(hue, 0.9, 1.0)
            return rgb
        elif self.color_mode == "spectrum":
            return (
                0.5 + 0.5 * np.sin(self.color_shift + index * 0.1),
                0.5 + 0.5 * np.sin(self.color_shift + index * 0.1 + 2.0),
                0.5 + 0.5 * np.sin(self.color_shift + index * 0.1 + 4.0)
            )
        elif self.color_mode == "fire":
            return (1.0, 0.3 + value * 0.7, value * 0.4)
        elif self.color_mode == "ocean":
            return (value * 0.3, 0.4 + value * 0.6, 0.7 + value * 0.3)
        elif self.color_mode == "candy":
            # Alternate between pink/purple and cyan/blue
            if index % 2 == 0:
                return (0.9, 0.4 + value * 0.6, 0.9)
            else:
                return (0.3, 0.7 + value * 0.3, 0.9)
        
        # Default fallback
        return (value, value, value)
    
    def draw_central_sphere(self) -> None:
        # Draw a central sphere that pulses with the bass
        radius = 0.3 + self.bass_energy * 0.3
        
        # Set color based on color mode
        if self.color_mode == "rainbow":
            r, g, b = colorsys.hsv_to_rgb(self.color_shift % 1.0, 0.8, 1.0)
        elif self.color_mode == "spectrum":
            r = 0.5 + 0.5 * np.sin(self.color_shift * 1.1)
            g = 0.5 + 0.5 * np.sin(self.color_shift * 0.7 + 2.0)
            b = 0.5 + 0.5 * np.sin(self.color_shift * 0.5 + 4.0)
        elif self.color_mode == "fire":
            r, g, b = 1.0, 0.3 + self.bass_energy * 0.7, self.bass_energy * 0.4
        elif self.color_mode == "ocean":
            r, g, b = self.bass_energy * 0.3, 0.4 + self.bass_energy * 0.6, 0.7 + self.bass_energy * 0.3
        elif self.color_mode == "candy":
            r, g, b = 0.9, 0.4 + self.bass_energy * 0.6, 0.9
        else:
            r, g, b = 1.0, 1.0, 1.0
        
        glColor4f(r, g, b, 0.7)
        
        # Draw sphere
        quadric = gluNewQuadric()
        gluQuadricDrawStyle(quadric, GLU_FILL)
        gluQuadricTexture(quadric, GL_TRUE)
        gluQuadricNormals(quadric, GLU_SMOOTH)
        gluSphere(quadric, radius, 32, 32)
        gluDeleteQuadric(quadric)
    
    def draw_spectrum(self) -> None:
        # Draw 3D circular spectrum
        num_bars = len(self.spectrum_data)
        radius = 2.0
        
        for i, value in enumerate(self.spectrum_data):
            if value < 0.05:  # Skip very low values for cleaner visualization
                continue
                
            # Calculate angle for this bar
            angle = (i / num_bars) * 2 * np.pi
            
            # Calculate position
            x = radius * np.cos(angle)
            z = radius * np.sin(angle)
            
            # Set height of bar based on spectrum value
            height = value * 2.5
            
            # Get color based on color mode
            r, g, b = self.get_spectrum_color(i, value)
            
            # Draw bar
            glPushMatrix()
            glTranslatef(x, 0, z)
            glRotatef(angle * 180 / np.pi, 0, 1, 0)
            self.draw_bar(height, (r, g, b))
            glPopMatrix()
    
    def draw_bar(self, height, color) -> None:
        if height <= 0:
            return
            
        glBegin(GL_QUADS)
        
        # Set color with alpha
        glColor4f(color[0], color[1], color[2], 0.8)
        
        # Front face
        width = 0.1
        depth = 0.1
        
        # Bottom
        y_bottom = 0
        # Top
        y_top = height
        
        # Front face
        glVertex3f(-width, y_bottom, depth)
        glVertex3f(width, y_bottom, depth)
        glVertex3f(width, y_top, depth)
        glVertex3f(-width, y_top, depth)
        
        # Back face
        glVertex3f(-width, y_bottom, -depth)
        glVertex3f(-width, y_top, -depth)
        glVertex3f(width, y_top, -depth)
        glVertex3f(width, y_bottom, -depth)
        
        # Left face
        glVertex3f(-width, y_bottom, -depth)
        glVertex3f(-width, y_bottom, depth)
        glVertex3f(-width, y_top, depth)
        glVertex3f(-width, y_top, -depth)
        
        # Right face
        glVertex3f(width, y_bottom, -depth)
        glVertex3f(width, y_top, -depth)
        glVertex3f(width, y_top, depth)
        glVertex3f(width, y_bottom, depth)
        
        # Top face with glowing effect
        glColor4f(color[0] * 1.2, color[1] * 1.2, color[2] * 1.2, 0.9)
        glVertex3f(-width, y_top, -depth)
        glVertex3f(-width, y_top, depth)
        glVertex3f(width, y_top, depth)
        glVertex3f(width, y_top, -depth)
        
        glEnd()
    
    def draw_waveform(self) -> None:
        # Draw 3D waveform as a ring in the center
        num_points = len(self.waveform_data)
        inner_radius = 0.7
        
        glLineWidth(3.0)  # Thicker line for better visibility
        glBegin(GL_LINE_STRIP)
        
        for i, value in enumerate(self.waveform_data):
            angle = (i / num_points) * 2 * np.pi
            
            # Scale value for visualization
            scaled_value = value * 0.6
            radius = inner_radius + scaled_value
            
            # Calculate position
            x = radius * np.cos(angle)
            z = radius * np.sin(angle)
            
            # Get color based on value and color mode
            if self.color_mode == GLVisualizerColorMode.Rainbow:
                hue = (self.color_shift + i / float(num_points)) % 1.0
                r, g, b = colorsys.hsv_to_rgb(hue, 0.9, 1.0)
            elif self.color_mode == GLVisualizerColorMode.Spectrum:
                r = 0.5 + 0.5 * np.sin(self.color_shift + i * 0.1)
                g = 0.5 + 0.5 * np.sin(self.color_shift + i * 0.1 + 2.0)
                b = 0.5 + 0.5 * np.sin(self.color_shift + i * 0.1 + 4.0)
            elif self.color_mode == GLVisualizerColorMode.Fire:
                intensity = abs(scaled_value) * 2
                r = 1.0
                g = 0.3 + intensity * 0.7
                b = intensity * 0.3
            elif self.color_mode == GLVisualizerColorMode.Ocean:
                intensity = abs(scaled_value) * 2
                r = intensity * 0.2
                g = 0.4 + intensity * 0.6
                b = 0.7 + intensity * 0.3
            elif self.color_mode == GLVisualizerColorMode.Candy:
                intensity = abs(scaled_value) * 2
                if i % 2 == 0:
                    r, g, b = 0.9, 0.4 + intensity * 0.6, 0.9  # Pink
                else:
                    r, g, b = 0.3, 0.7 + intensity * 0.3, 0.9  # Blue
            else:
                r, g, b = 1.0, 1.0, 1.0
                
            glColor3f(r, g, b)
            glVertex3f(x, scaled_value * 0.7, z)
        
        glEnd()
    
    def update_data(self, spectrum, waveform) -> None:
        self.spectrum_data = spectrum
        self.waveform_data = waveform
        
        # Calculate bass energy (lower frequency bands)
        if len(spectrum) >= 10:
            self.bass_energy = np.mean(spectrum[:10])
        
        # Update color shift
        self.color_shift += 0.01 + self.bass_energy * 0.05
        
        # Update rotation
        self.rotation += 0.3 + self.bass_energy * 3.0
        
        # Update particles
        self.update_particles()
        
        self.update()
    
    def set_color_mode(self, mode) -> None:
        self.color_mode = mode
